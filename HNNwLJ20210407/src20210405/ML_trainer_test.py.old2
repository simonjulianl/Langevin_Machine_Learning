from parameters.MC_parameters        import MC_parameters
from parameters.MD_parameters        import MD_parameters
from parameters.ML_parameters        import ML_parameters
from phase_space                     import phase_space
from integrator.linear_integrator    import linear_integrator
from utils.data_io                   import data_io

import torch

if __name__=='__main__':

    tau_long         = MD_parameters.tau_long
    tau_cur          = tau_long

    # io varaiables
    phase_space = phase_space.phase_space()
    hamiltonian_obj = MD_parameters.hamiltonian_obj
    linear_integrator_obj = linear_integrator( MD_parameters.integrator_method, MD_parameters.integrator_method_backward )
 
    torch.manual_seed(2233)

    nsample = 8
    nparticle = MC_parameters.nparticle
    DIM = 2   
    boxsize = MC_parameters.boxsize
    list_shape = [nsample,nparticle,DIM]

    q_label = torch.zeros(list_shape,dtype=torch.float64)
    p_label = torch.zeros(list_shape,dtype=torch.float64)

    # change to read from file
    q_label[:,0,:] = -0.25*boxsize
    q_label[:,1,:] =  0.25*boxsize

    # change to read from file
    q_list = q_label + 0.5*(torch.rand(list_shape,dtype=torch.float64)-0.5)
    p_list = torch.rand(list_shape,dtype=torch.float64)-0.5

    nepoch = 20000

    optimizer = ML_parameters.opt.create(hamiltonian_obj.net_parameters())

    for e in range(nepoch):
        optimizer.zero_grad()
        phase_space.set_q(q_list)
        phase_space.set_p(p_list)
        qp_list = linear_integrator_obj.one_step(hamiltonian_obj, phase_space, tau_cur)
        # qp_list.shape = [2,nsamples,nparticle,DIM]
        q_out = qp_list[0]
        p_out = qp_list[1]
        loss = torch.mean((q_out - q_label)**2 + (p_out - p_label)**2)
        loss.backward(retain_graph=True)
        optimizer.step()
        if e%(nepoch//100)==0: print('e ',e,' loss ',loss)

