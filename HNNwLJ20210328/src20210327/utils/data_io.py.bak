import torch
import pickle
import gzip
import os
from MC_parameters import MC_parameters
from MD_parameters import MD_parameters

class data_io:

    def __init__(self,root_dir_name):
        ''' set up the root directory for all data '''
        self.root_dir = root_dir_name

    def read_init_qp(self, filename):
        '''
            returns
            torch.tensor of qp_list

            shape of q_list is [nsamples,nparticles,DIM]
            shape of p_list is [nsamples,nparticles,DIM]
        '''
        full_path = self.root_dir + filename
        q_list, p_list = torch.load(full_path)

        assert q_list.shape == p_list.shape

        return (q_list, p_list)


    def write_init_qp(self, qp_list, filename):
        ''' write or append to filename for qp_list

        Parameters
        ----------
        filename : string
        qp_list : torch.tensor q_list shape is [nsamples, nparticle, DIM]
                  tensor of (q,p) states
                  shape is [(q,p), (new_mcs x mc step), nparticle, DIM]

        use in MC_sample.py
        '''
        full_path = self.root_dir + filename
        torch.save(qp_list, full_path)


    def read_trajectory_qp(self, filename):
        ''' given a temporary filename, read the qp paired pts trajectory for testing or gold standard

        returns
        torch tensor of qp_list

        use in MD_sample.py
        '''

        qp_list = pickle.load(handle)

        return qp_list

    def write_trajectory_qp(self, filename, qp_trajectory, mode):
        ''' write or append to temporary filename for qp_trajectory

        Parameters
        ----------
        tmp_filename : string
        no_file : int
                i th saved file
        qp_trajectory : torch.tensor
                  tensor of (q,p) states
                  shape is [iteration_batch, (q, p), nsamples, nparticle, DIM]

        returns
        torch tensor
        qp paired pts trajectory

        use in MD_sample.py
        '''

        with gzip.open( tmp_filename + '_{}.pt'.format(no_file), 'wb') as handle: # overwrites any existing file
            pickle.dump(qp_trajectory, handle, protocol=pickle.HIGHEST_PROTOCOL)
            handle.close()



    def read_crash_qp(self, filename):
        ''' given a filename, read the qp pts for retraining

            returns
            torch tensor pair of qp_list '''

        with gzip.open( filename , 'rb') as handle: # overwrites any existing file
            qp_list = pickle.load(handle)

            return qp_list

    def write_crash_qp(self, filename, crash_qp):
        ''' write or append to filename  for retraining '''

        with gzip.open( filename, 'wb') as handle: # overwrites any existing file
            pickle.dump(crash_qp, handle, protocol=pickle.HIGHEST_PROTOCOL)
            handle.close()
